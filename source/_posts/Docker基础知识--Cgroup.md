---
title: Docker基础知识--Cgroup
urlname: czpxfz
date: 2020-01-08 22:24:05 +0800
tags: [docker,Cgroup]
categories: []
---

## 前言

上篇中，已经讨论了 Docker 作为虚拟化技术，所采用的基础技术 namespace，以此来进行资源隔离。同时，我们也想到了另外一个问题，在资源隔离后，实际上仍然是占用 host 的资源，如何保证资源（CPU、内存和 IO）被有效的控制，为此 Docker 引入另外一项关键技术---Control group ( `Cgroup`)。

## 何为 Cgroup

在 Linux 系统中，内核本身的调度和管理并不对进程和线程进行区分，只会根据`clone`创建时传入的值不同，来区分进程和线程。
Cgroup 全称为 `control grup` ，由 06 年合入 linux 内核，就是把任务放在一个组里进行控制。我们给出官方的定义：
cgroup 是 Linux 内核提供的一种机制，这种机制可以根据需要把一系列的系统任务和对应的子任务整合（或者分割）到资源划分等级的不同组内。从而对系统的资源，提供了一个完整的控制框架。

## Cgroup 的四个特点

1. cgroup 的 API 以仿文件系统的方式实现，用户态的进程可以通过管理文件的方式完成组织管理
1. cgroup 的组织管理，最小颗粒度为线程级别，此外用户有权限创建和销毁 cgroup，从而实现资源再分配
1. 所有的资源管理的功能都以**子系统**的方式实现，保证 API 接口的统一性
1. 所有子系统的资源组与父任务相同

所有我们，可以认为，cgroup 是附加在程序上的钩子（hook），通过程序运行时，对资源进行调度触发钩子达到资源监控和控制。

## Cgroup 原理

在介绍 Cgroup 原理之前，我们先熟悉两个概念：组织结构与基本规则、子系统。

### Cgroup 的组织结构

传统的 Unix 体系中，首先启动 init 的进程作为 root 进程，再由 init 进程扩展创建子系统作为子节点，而每个子节点又重复此方式，往复循序。而 Cgroup 也创建类似树状结构，子节点继承自父节点。
与传统 init 方式不同，cgroup 运行多个父节点，即 cgroup 子节点对应的父节点可以有多个。在 Docker 中每个子系统独自构成一个层级，便于管理。

#### Cgroup 的组织规则

1. 同一个层级可以附加多个子系统
1. 一个子系统可以附加到多个层级，但前提是，关联的层级仅能与此子系统相连，即当且仅当目标层级只有唯一一个子系统时。
1. 系统每次创建一个新的层级，该系统上所有任务默认加入这个新建层级的初始化层级，即 `root cgroup` 。任务在同一层级，仅能有一份。
1. 任务在 `fork/clone`  自身时，创建的子任务默认与原任务在同一层级（cgroup）中，但子任务运行被移动到不同个的 cgroup 中。

### 子系统介绍

blkio --  这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB  等等）。
cpu --  这个子系统使用调度程序提供对  CPU  的  cgroup  任务访问。
cpuacct --  这个子系统自动生成  cgroup  中任务所使用的  CPU  报告。
cpuset --  这个子系统为  cgroup  中的任务分配独立  CPU（在多核系统）和内存节点。
devices --  这个子系统可允许或者拒绝  cgroup  中的任务访问设备。
freezer --  这个子系统挂起或者恢复  cgroup  中的任务。
memory --  这个子系统设定  cgroup  中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告。
net_cls --  这个子系统使用等级识别符（classid）标记网络数据包，可允许  Linux  流量控制程序（tc）识别从具体  cgroup  中生成的数据包。
ns --  名称空间子系统。
