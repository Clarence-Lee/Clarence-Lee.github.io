
---
title: Docker基础知识--Cgroup
date: 2020-01-08 22:24:05 +0800
tags: [docker,Cgroup]
categories: 
---
<a name="JddnB"></a>
## 前言
上篇中，已经讨论了Docker作为虚拟化技术，所采用的基础技术namespace，以此来进行资源隔离。同时，我们也想到了另外一个问题，在资源隔离后，实际上仍然是占用host的资源，如何保证资源（CPU、内存和IO）被有效的控制，为此Docker引入另外一项关键技术---Control group ( `Cgroup`)。
<a name="RUUyP"></a>
## 何为Cgroup
在Linux系统中，内核本身的调度和管理并不对进程和线程进行区分，只会根据`clone`创建时传入的值不同，来区分进程和线程。<br />Cgroup全称为 `control grup` ，由06年合入linux内核，就是把任务放在一个组里进行控制。我们给出官方的定义：<br />cgroup是Linux内核提供的一种机制，这种机制可以根据需要把一系列的系统任务和对应的子任务整合（或者分割）到资源划分等级的不同组内。从而对系统的资源，提供了一个完整的控制框架。
<a name="TwlUt"></a>
## Cgroup的四个特点

1. cgroup的API以仿文件系统的方式实现，用户态的进程可以通过管理文件的方式完成组织管理
1. cgroup的组织管理，最小颗粒度为线程级别，此外用户有权限创建和销毁cgroup，从而实现资源再分配
1. 所有的资源管理的功能都以**子系统**的方式实现，保证API接口的统一性
1. 所有子系统的资源组与父任务相同

所有我们，可以认为，cgroup是附加在程序上的钩子（hook），通过程序运行时，对资源进行调度触发钩子达到资源监控和控制。

<a name="W4If8"></a>
## Cgroup原理
在介绍Cgroup原理之前，我们先熟悉两个概念：组织结构与基本规则、子系统。
<a name="HbJbH"></a>
### Cgroup的组织结构
传统的Unix体系中，首先启动init的进程作为root进程，再由init进程扩展创建子系统作为子节点，而每个子节点又重复此方式，往复循序。而Cgroup也创建类似树状结构，子节点继承自父节点。<br />与传统init方式不同，cgroup运行多个父节点，即cgroup子节点对应的父节点可以有多个。在Docker中每个子系统独自构成一个层级，便于管理。
<a name="mN4zx"></a>
#### Cgroup的组织规则

1. 同一个层级可以附加多个子系统
1. 一个子系统可以附加到多个层级，但前提是，关联的层级仅能与此子系统相连，即当且仅当目标层级只有唯一一个子系统时。
1. 系统每次创建一个新的层级，该系统上所有任务默认加入这个新建层级的初始化层级，即 `root cgroup` 。任务在同一层级，仅能有一份。
1. 任务在 `fork/clone` 自身时，创建的子任务默认与原任务在同一层级（cgroup）中，但子任务运行被移动到不同个的cgroup中。
<a name="1CXfE"></a>
### 子系统介绍
blkio -- 这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）。<br />cpu -- 这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问。<br />cpuacct -- 这个子系统自动生成 cgroup 中任务所使用的 CPU 报告。<br />cpuset -- 这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点。<br />devices -- 这个子系统可允许或者拒绝 cgroup 中的任务访问设备。<br />freezer -- 这个子系统挂起或者恢复 cgroup 中的任务。<br />memory -- 这个子系统设定 cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告。<br />net_cls -- 这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包。<br />ns -- 名称空间子系统。





